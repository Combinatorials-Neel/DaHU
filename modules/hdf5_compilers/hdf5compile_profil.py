"""
Functions for DEKTAK parsing
"""
from ..functions.functions_profil import check_for_profil
from ..hdf5_compilers.hdf5compile_base import *
import io


def read_header_from_dektak(file_string):
    header_dict = {}
    lines = io.StringIO(file_string).readlines()
    for line in lines[4:45]:
        split = line.strip().split(',')
        key, value = split[0], split[-1]
        if key == 'TargetName':
            value = f'({split[-2].strip('(')},{split[-1].strip(')')})'
        header_dict[key] = value
    del header_dict['FullFilename']
    return header_dict

def read_data_from_dektak(file_string, header_length=46):
    file = io.StringIO(file_string)
    asc2d_dataframe = pd.read_csv(file, skiprows=header_length)
    asc2d_dataframe.rename(columns={' z(raw/unitless)': 'Profile'}, inplace=True)
    asc2d_dataframe.rename(columns={'y(um)': 'Distance'}, inplace=True)
    return asc2d_dataframe

def position_from_tuple(scan_number):
    pattern = r'\((\d+),(\d+)\)'
    match = re.search(pattern, scan_number)
    x = (int(match.group(2)) - 10) * 5  # Header tuple has the format (y,x)
    y = (10 - int(match.group(1))) * 5
    return x, y

def set_instrument_from_dict(header_dict, node):
    """
    Writes the contents of the moke_dict dictionary to the HDF5 node.

    Args:
        moke_dict (dict): A dictionary containing the MOKE data and metadata, generated by the read_header_from_moke and read_data_from_moke functions.
        node (h5py.Group): The HDF5 group to write the data to.
    Returns:
        None
    """
    for key, value in header_dict.items():
        if isinstance(value, dict):
            set_instrument_from_dict(value, node.create_group(key))
        else:
            node[key] = value

    return None


def write_dektak_to_hdf5(hdf5_path, measurement_dict, mode='a'):
    with h5py.File(hdf5_path, mode) as hdf5_file:
        for file_name, file_string in measurement_dict.items():
            if file_name.endswith('.asc2d'):
                header_dict = read_header_from_dektak(file_string)
                asc2d_dataframe = read_data_from_dektak(file_string)
                scan_number = header_dict['TargetName']

                x_pos, y_pos = position_from_tuple(scan_number)

                scan_group = f"/entry/profil/scan_{scan_number}"
                scan = hdf5_file.create_group(scan_group)

                # Instrument group for metadata
                instrument = scan.create_group("instrument")
                instrument.attrs["NX_class"] = "HTinstrument"
                instrument["x_pos"] = convertFloat(x_pos)
                instrument["y_pos"] = convertFloat(y_pos)
                instrument["x_pos"].attrs["units"] = "mm"
                instrument["y_pos"].attrs["units"] = "mm"

                set_instrument_from_dict(header_dict, instrument)

                # Measurement group for data
                data = scan.create_group("measurement")
                data.attrs["NX_class"] = "HTmeasurement"
                for col in asc2d_dataframe.columns:
                    node = data.create_dataset(col, data=np.array(asc2d_dataframe[col]), dtype='float')
                    if col == 'Profile':
                        node.attrs['unit'] = 'nm'
                    elif col == 'Distance':
                        node.attrs['unit'] = 'Î¼m'

    return None



def write_dektak_results_to_hdf5(hdf5_path, results_dict, target_x, target_y):
    if not check_for_profil(hdf5_path):
        raise KeyError("Profilometry not found in file. Please check your file")

    with h5py.File(hdf5_path, mode='a') as hdf5_file:
        profil_group = hdf5_file['entry/profil']
        for position, position_group in profil_group.items():
            instrument_group = position_group.get('instrument')
            if instrument_group["x_pos"][()] == target_x and instrument_group["y_pos"][()] == target_y:
                results = position_group.create_group("results")
                try:
                    for key, result in results_dict.items():
                        results[key] = result
                        results["Measured Height"].attrs["units"] = "nm"
                except KeyError:
                    raise KeyError('Given results dictionary not compatible with current version of this function.'
                                   'Check compatibility.')

    return None